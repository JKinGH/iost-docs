---
id: version-1.0.4-VM
title: VM
sidebar_label: VM
original_id: VM
---

Мы считаем, что хорошая реализация виртуальной машины должна быть элегантной, простой в использовании и надежной. Сравнив плюсы и минусы EVM, EOS, C Lua и V8, мы принципиально разрешили необоснованные конструкции из EVM и EOS. Нам удалось создать IOST VM на основе V8 из-за ее высокой производительности в Chrome.

## 1. Структура и дизайн IOST V8VM

VMManager находится в ядре V8VM. Он имеет три основные функции:

![statedb](assets/2-intro-of-iost/VM/V8VM.png)
* <font color="#0092ff">VM Вход. </font>Он связывает внешние запросы с другими модулями, включая запросы RPC, валидацию блока, валидацию Tx и т.д. Работа передается VMWorker после предварительной обработки и форматирования.
* <font color="#0092ff">VMWorker управление жизненным циклом. </font>Число workers(работников) устанавливается динамически на основе нагрузки системы. Это позволяет повторно использовать workers(работников). Внутри workers(рабочих) JavaScript производит запуск (hot launch) и постоянство моментальных снимков в виде «горячих точек» (Sandbox) помогают сократить частое создание виртуальных машин и избежать большой нагрузки на процессор и память при загрузке одного и того же кода. Это увеличит пропускную способность системы, позволяя IOST V8VM дышать даже при обработке контрактов с массивной пользовательской базой, например fomo3D.
* <font color="#0092ff">Управление интерфейсом с базой данных State(Management of interface with State database). </font>Это обеспечивает атомарность каждой транзакции IOST, отрицая всю транзакцию, когда есть ошибка с недостатком средств. В то же время двухуровневый кеш достигается в базе данных State, прежде чем его можно сбросить до RocksDB.

## 2. Проектирование ящиков Sandbox

![statedb](assets/2-intro-of-iost/VM/sandbox.png)

В качестве полезной нагрузки для исполнения смарт-контракта JavaScript Sandbox взаимодействует с V8VM и упаковывает вызов для Chrome V8. Существует два этапа: компиляция и выполнение.

### Этап компиляции

В основном для разработки и публикации смарт-контрактов он имеет две функции::

* <font color="#0092ff">Упаковка контракта. </font>Упаковка смарт-контрактов，на основе внедрения webpack，устанавливает весь код JavaScript в рамках текущего проекта контракта，и автоматизирует установку зависимостей. Можно разработать крупные контрактные проекты для IOST V8VM. В то же время модули IOST V8VM и Node.js полностью совместимы，вы можете легко использовать такие методы, как require, module.exports и export, чтобы предоставить разработчикам контрактов собственный опыт разработки JavaScript.
* <font color="#0092ff">Снимок контракта. </font>Благодаря технологии моментальных снимков компиляция повышает производительность создания изолированной среды и контекста — антисериализация моментального снимка приведет к результату во время выполнения и значительно увеличит скорость загрузки и выполнения JavaScript.

### Этап выполнения

В основном для выполнения контрактов в блокчейне он также имеет две функции:

* <font color="#0092ff">Загрузка виртуальной машины (LoadVM). </font>Завершает инициализацию виртуальной машины, включая создание объекта Chrome V8, настройку параметров выполнения системы, импорт соответствующих библиотек классов JavaScript и т.д. Некоторые библиотеки классов JavaScript включают:

| Class Library          | Features   |
| --------     | -----  |
| Blockchain   | Node.js-как модульная система, включая кэширование модулей, предварительную компиляцию, циклические вызовы и т. д.|
| Event        | Чтение / запись JavaScript с помощью библиотеки State и откат, когда контракты сталкиваются с ошибками.|
| NativeModule | Функции связанные с блокчейном, включая transfer(перечисление), withdraw(вывод) и получение информации о текущем блоке и Tx(транзакции).|
| Storage      | Реализация событий. Внутренние события JavaScript-контрактов могут принимать обратные вызовы после перехода по цепочке.|

* <font color="#0092ff">Выполнение. </font>Окончательное выполнение JavaScript смарт-контракта. IOST V8VM будет запускать контракт на автономном потоке, контролировать состояние прогона, и будет `Terminate`(Завершать) текущий запуск при возникновении ошибки, недостатке ресурсов, или истечении времени, и возвращать аномальные результаты.
